
\chapter{Related Work}
\label{sec:relatedwork}

We discuss related work in three related fields, XML fragmentation, parallel XML
processing and XML database Techniques.

\section{XML Fragmentation}

Fragmentation is an important way of efficient processing XML documents, which
divides an XML document in fragments and processes them in parallel.
Fragmentation is the premise of data-parallel computation algorithms, and has
been intensively
studied~\cite{ARBM06,DaGP14,CFKL12,NEMH07,OgTP13,LiZZ17,CFKL12,DaGP14}. We
discuss three ways of fragmentations of XML documents in this section.

\subsection{Fragmentation of Trees}

Data fragmentation is characterized by physical changes to the dataset, that is,
the dataset is fragmented and allocated to multiple computational
nodes~\cite{BrMa14}. Kling et al.~\cite{kling11:dist_xml} modeled fragmentation
as horizontal and vertical in terms of XML schema~\cite{schema} that is a
language for expressing constraints about XML documents. We now discuss these
two fragmentations.

\subsubsection{Horizontal Fragmentation}
\label{sec:hfragment}

Horizontal fragmentation is to divide a document tree into multiple fragments
and every fragment follows the same schema of the original XML document. The
whole document is a simple collection of fragments. Horizontal fragmentation is
rather straightforward and widely used in parallel XML
processing~\cite{DaGP14,BoLS09,AfDG15,CCMN15}. Since the fragments follow the
same schema, the queries can be evaluated on them by considering the schema.

\subsubsection{Vertical Fragmentation}
\label{sec:vfragment}

Vertical fragmentation, on the other hand, is a fragmentation that extracts
subtrees from the middle of the tree, thus following different schemas. Though
this fragmentation does not usually work well for parallel XML processing, it is
worth studying. This is because it is a possible and  important in case when the
data are integrated from different sites or organizations~\cite{CFKL12,KlOD10}.

\subsection{Fragmentation of XML Text}

Compared to these tree-based fragmentation techniques, the fragmentation in this
study is based on serialized text, which means we cast the partition on the
plain text of an XML document in stead of the XML tree parsed from the document.
The main advantage of our text-based fragmentation is that we can assign the
chunks over distributed file systems~\cite{dfs} that are cut by default. Similar
idea was introduced by Choi et al.~\cite{ChLL14} in which they added labels to
make every chunk a well-formed tree in a preparsing phase.

\subsection{Holes and Fillers}

Bose et al. proposed a fragmentation model~\cite{bose2003query}. Bese on this,
Bose  et al. proposed a system called Xfrag~\cite{bose2005xfrag}. In this
system, an document is divided into multiple sub documents called fillers,
where other fragments (the fillers) may fit.  Cong et al.~\cite{CFKL12} and
Nomura et al. \cite{NEMH07} adopted a tree-shaped fragment that contains
original nodes and hole nodes, where a hole node represents a link to a missing
subtree, and represented the whole document as a tree of fragments. The key part
of their approaches to decouple dependencies between evaluations on fragments so
as to perform them in parallel.


\section{Parallel XML Processing}
\label{sec:paralleleval}

Many existing studies address the topic of XML processing in
parallel~\cite{BoLS09,PaZC08,LuGa08,Mats09,SAFu05}. We discuss parallel XML
processing in this section.

\subsection{Tree Accumulation and Reduction}

There are some exsisting ideas of dividing the XML documents and running the
computation for trees called tree reduction. Kakehi et al.~\cite{KaME07} showed
a parallel tree reduction algorithm from the nodes in chunks. Based on the idea
given by Kakehi et al., Emoto and Imachi~\cite{EmIm12} developed a parallel tree
reduction algorithm on Hadoop, and Matsuzaki and Miyazaki~\cite{MaMi16}
developed a parallel tree accumulation algorithm. A similar approach was taken
by Sevilgen et al.~\cite{SAFu05} who developed a simpler version of tree
accumulations over the serialized representation of trees.

\subsection{XML Streaming}

Stream processing is a possible approach for (parallel) online data analysis.
Parallel algorithms have been studied to accelerate stream processing
of large XML data. For example, XMLTK~\cite{AGGR02} is an XML stream processing
tool designed for scalable XML querying. Y-Filter~\cite{ZhPC10} applies multiple
queries in parallel for a stream of XML data. Among these studies, Ogden et
al.~\cite{OgTP13} achieved the highest throughput, 2.5 GB/s, based on the
parallel pushdown transducer. Although it is faster than our implementation of
partial tree, which is 1 GB/s, the class of queries we support is more
expressive than that of PP-transducer, which does not support order-aware
queries. In parallel pushdown transducers \cite{LiZZ17}, a given document is
modeled as a sequence of matched brackets and a fragment is represented as a
sequence of unmatched brackets.


\subsection{MapReduce-based XML Processing}
\label{sec:mapreduce}

MapReduce~\cite{DeGh04} is a promising approach to large-scale XML processing,
which can run on top of clusters of commodity computers. It is suitalbe for
scalability as the size of XML data increases very rapidly.
Hadoop~\cite{HadoopWhit12}, which is a porpular implementtation of MapReduce, is
a common infrastructure for large-scale data processing, and to parallel
streaming~\cite{OgTP13,LiZZ17}. There have been several studies in this
direction~\cite{BCMU13,CFKL12,DaGP14,EmIm12,DaGP14,MaMi16}. One of earlier work
is by Choi et al.~\cite{CLKL12} called HadoopXML, which processes XML data in
parallel by applying SAX~\cite{sax} for each chunk. Including this work, most of
the existing MapReduce-based frameworks supports a small subset of XPath with
\texttt{child} and \texttt{descendant} axes with
predicates~\cite{CCMN15,AfDG15,DaGP14,DaGK14}. Instead, they extend the
expressiveness by the support of some query functionality (subsets of XQuery).
To cope with the problem of absolute performance of MapReduce, there is a few
work to use similar but more efficient frameworks, for example Apache
Flink~\cite{CCMN15}.


\subsection{Parallel Processing of queries}

Parallel XML processing has been actively studied after the paper presented by
Bordawekar et al.~\cite{BoLS09}, which closely relates to our study. The paper
proposes three strategies for XPath queries in parallel: data partition
strategy, query partition strategy, and hybrid partition strategy. . In fact,
there were some studies in the parallel programming community from 1990's.
Skillicorn developed a set of parallel computational patterns for trees called
tree skeletons, and showed they can be used for processing structured
documents~\cite{Skil97}. The main idea in parallelizing XPath queries was to
convert XPath queries into (tree) automata~\cite{comon2007tree}, and then
compute automata in parallel with tree skeletons. This idea was extended to
support a larger class of XPath including \texttt{following-sibling} by Nomura
et al.~\cite{NEMH07}. \cite{KrYa10,PLZC07,ZhPC10} focus on XPath queries
implemented in a shared-memory environment. \cite{AAHa11} proposed ideas about
XML processing in a forward and forward manner, which is helpful for our
research to support backward and upward queries as well. Liu et
al.~\cite{LFLQ08} developed a parallel version of structural join algorithm. The
study~\cite{ZaBS15} focuses processing a locality-aware partitioning in parallel
database systems. Cong et al.~\cite{CFKL12} formalized parallel processing of
XPath queries using the partial evaluation technique: the idea existing behind
their partial evaluation is similar to automata.

\section{XML Database Techniques}

\subsection{Indexing and Labeling Schemes}

Indexing is a hot topic for improving the performance of XML queries processing.
\cite{CVZZ08,ToGr02,JLWO03} are related to this field. They examined the indices
on different types of trees, including B+-tree, R-tree, and XR-tree. O'Neil et
al.~\cite{OOPC04} proposed an index called ORDPATH for natively supporting XML
data type. This index makes it possible to process XML queries  inside the
database with downward XPath queries and allows update operations. Since this
length of this index increases with respect to the size of XML documents, the
length will be very long in case the XML documents are large. Pal et
al.~\cite{PCSS04} studied how to improve the query performance by introducing
two indexes to nodes and values in SQL Server. Li et al~\cite{LiLi05} improved
OrdPath by reducing the length of ORDPATH index when inserting. Min et
al.~\cite{MLCh07} proposed an efficient labeling scheme, called EXEL, which
incurs no re-labeling of nodes when inserting nodes. Finis et al~\cite{FBKF15}
Proposed an idea mainly on how to maintain and query hierarchical data at a high
rate of complex, possibly skewed structural updates. There indexes inspire our
deisgn of index scheme on XML document to make ours in a more efficient way.


\subsubsection{Joins Algorithms}

Join processing is central to database implementation~\cite{graefe1993query}.
There are two join algorithms commonly used in XML processing, structural join
and twig join.

Structural join~\cite{AlJYK02} is mostly based on numbering
indexing\cite{numbering}, which numbers a nested intervals on nodes and is
commonly used in XML and other database
applications~\cite{ZNDI01,HAJR03,ZNDI01}. By using the information of start
position, end position and level of each node, the parent-child and
ancestor-descendant relationships of nodes can be determined by a merge join on
two lists of nodes. In 2001, a earily study~\cite{LiMo01} proposed three joint
algorithms for processing XML queries, which were similar to structural join. In
2002, Quanzhong Li et al. first proposed structural join in~\cite{AlJYK02}.
Jiang et al.~\cite{JLWO03} improved the structural join with a novel tree
structure, called XR-tree, which is suitable for identifying the descendants of
a given node with optimized worst case I/O cost. Le Liu et al.~\cite{LFLQ08}
first applied structural join in parallel over shared-memory environments.

Twig joins are also commonly used for maching a part of an XML
documents~\cite{jiang2003holistic,lu2005efficient,lu2005tjfast,fontoura2005optimizing}.
In twig join, a query is represented as a twig patten, and then is searched on
the target XML document. One of the early twig joins was \cite{BrKS02}. In the
paper, a holistic twig join algorithm, called TwigStack was proposed for
matching an XML query. There are also variants of twig joins then
devleoped~\cite{CLTH06,QiYD07}. In 2009, Machdi et al.~\cite{MaAK09} implemented
the idea in parallel on multiple cores and in 2012 Choi et al.~\cite{CLKL12}
studied the twig joins on Hadoop in a parallel manner.


%\section{Others}
%
%\cite{PLZC07,WZYu08} focused on XML parsing, which is related to our parsing
%algorithm. Yinfei et al.~\cite{PaZC08} developed an algorithm for parsing the
%XML data in parallel without any sequential preparsing phase.
%
% MonetDB~\cite{BGvM06}

%They are inconvenient in  practice because their algorithms were designed for
%evaluating small subsets (e.g., child and descendant axes with predicates in
%\cite{CFKL12,kling11:dist_xml}) of XPath by using dedicated data structures. Use
%of dedicated data structures necessitate implementing XML database engines
%nearly from scratch in practice. Even fallbacks to sequential evaluation of
%queries beyond a parallelizable set then become nontrivial. This means that we
%have to design a full stack of XML database management systems in practice. In
%summary, existing divide-and-conquer approaches are inherently a hard
%engineering option in parallelizing XPath queries.
